
#include "Generator.h"

const char * const Generator::signature =
    "// Generated by json-cpp-gen by Viktor Chlumsky\n"
    "// https://github.com/Chlumsky/json-cpp-gen\n\n";

const unsigned Generator::FEATURE_CSTDLIB = 0x01;
const unsigned Generator::FEATURE_CSTDIO = 0x02;

Generator::Generator(const std::string &className, const StringType *stringType, const Settings &settings) : mStringType(stringType), mSettings(settings), featureBits(0) {
    std::string namePart;
    for (char c : className) {
        if (c == ':') {
            if (!namePart.empty()) {
                classNamespaces.push_back((std::string &&) namePart);
                namePart.clear();
            }
        } else
            namePart.push_back(c);
    }
    this->className = (std::string &&) namePart;
}

void Generator::addTypeInclude(const std::string &includeAddress) {
    typeIncludes.push_back(includeAddress);
}

void Generator::addFeature(unsigned featureBit) {
    featureBits |= featureBit;
}

std::string Generator::getJsonMemberNameLiteral(const std::string &memberName) const {
    return "\""+memberName+"\""; // TODO
}

std::string Generator::getJsonEnumValueLiteral(const std::string &enumValue) const {
    return "\""+enumValue+"\""; // TODO
}

std::string Generator::generateFunctionName(const char *prefix, const Type *type) {
    std::string functionName = prefix+formatName(type->name().body(), NameFormat::CAMELCASE_CAPITAL);
    for (char c : type->name().suffix()) {
        if (isalnum(c))
            functionName.push_back(c);
        else if (c == '[')
            functionName.push_back('_');
    }
    while (usedFunctionNames.find(functionName) != usedFunctionNames.end())
        functionName.push_back('_'); // TODO
    usedFunctionNames.insert(functionName);
    return functionName;
}

std::string Generator::generateErrorStatement(const char *errorName) const {
    return std::string(settings().noThrow ? "return" : "throw")+" Error::"+errorName;
}

std::string Generator::beginNamespace() const {
    std::string code;
    for (const std::string &namespaceName : classNamespaces)
        code += "namespace "+namespaceName+" {\n\n";
    return code;
}

std::string Generator::endNamespace() const {
    std::string code;
    for (size_t n = classNamespaces.size(); n; --n)
        code += "\n}\n";
    return code;
}
