
#include "Generator.h"

#include "NameFormat.h"

const char *const Generator::signature =
    "// Generated by json-cpp-gen by Viktor Chlumsky\n"
    "// https://github.com/Chlumsky/json-cpp-gen\n\n";

const unsigned Generator::FEATURE_CSTDLIB = 0x01;

Generator::Generator(const std::string &className, const StringType *stringType, const Settings &settings) : mStringType(stringType), mSettings(settings), featureBits(0) {
    std::string namePart;
    for (char c : className) {
        if (c == ':') {
            if (!namePart.empty()) {
                classNamespaces.push_back((std::string &&) namePart);
                namePart.clear();
            }
        } else
            namePart.push_back(c);
    }
    this->className = (std::string &&) namePart;
}

void Generator::addTypeInclude(const std::string &includeAddress) {
    typeIncludes.push_back(includeAddress);
}

void Generator::addFeature(unsigned featureBit) {
    featureBits |= featureBit;
}

std::string Generator::getJsonMemberNameLiteral(const std::string &memberName) const {
    return "\""+memberName+"\""; // TODO
}

std::string Generator::getJsonEnumValueLiteral(const std::string &enumValue) const {
    return "\""+enumValue+"\""; // TODO
}

std::string Generator::charLiteral(char c) {
    switch (c) {
        case '\0': return "'\\0'";
        case '\b': return "'\\b'";
        case '\f': return "'\\f'";
        case '\n': return "'\\n'";
        case '\r': return "'\\r'";
        case '\t': return "'\\t'";
        case '\'': return "'\\''";
        case '\\': return "'\\\\'";
    }
    if (c >= 0x20 && c < 0x7f) {
        char buffer[] = "'#'";
        buffer[1] = c;
        return buffer;
    } {
        char buffer[] = "'\\x##'";
        buffer[3] = "0123456789abcdef"[c>>4&0x0f];
        buffer[4] = "0123456789abcdef"[c&0x0f];
        return buffer;
    }
}

std::string Generator::generateFunctionName(const char *prefix, const Type *type) {
    std::string functionName = prefix+formatName(type->name().body(), NameFormat::CAMELCASE_CAPITAL);
    for (char c : type->name().suffix()) {
        if (isalnum(c))
            functionName.push_back(c);
        else if (c == '[')
            functionName.push_back('_');
    }
    while (usedFunctionNames.find(functionName) != usedFunctionNames.end())
        functionName.push_back('_'); // TODO
    usedFunctionNames.insert(functionName);
    return functionName;
}

std::string Generator::beginNamespace() const {
    std::string code;
    for (const std::string &namespaceName : classNamespaces)
        code += "namespace "+namespaceName+" {\n\n";
    return code;
}

std::string Generator::endNamespace() const {
    std::string code;
    for (size_t n = classNamespaces.size(); n; --n)
        code += "\n}\n";
    return code;
}
